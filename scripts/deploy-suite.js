const environments = require("../environments");
const hre = require("hardhat");
const ethers = hre.ethers;
const network = hre.network.name;
const confirmations = network == "hardhat" ? 1 : environments.confirmations;
const tipMultiplier = ethers.BigNumber.from(environments.tipMultiplier);
const tipSuggestion = "1500000000"; // ethers.js always returns this constant, it does not vary per block
const maxPriorityFeePerGas = ethers.BigNumber.from(tipSuggestion).mul(tipMultiplier);

const protocolConfig = require("./config/protocol-parameters");
const authTokenAddresses = require("./config/auth-token-addresses");

const Role = require("./domain/Role");
const { deployProtocolDiamond } = require("./util/deploy-protocol-diamond.js");
const { deployProtocolClients } = require("./util/deploy-protocol-clients.js");
const { deployProtocolConfigFacet } = require("./util/deploy-protocol-config-facet.js");
const { deployProtocolHandlerFacets } = require("./util/deploy-protocol-handler-facets.js");
const { verifyOnTestEnv } = require("./util/report-verify-deployments");
const { getInterfaceIds, interfaceImplementers } = require("./config/supported-interfaces.js");
const { deploymentComplete, getFees, writeContracts } = require("./util/utils");
const AuthTokenType = require("../scripts/domain/AuthTokenType");

/**
 * Deploy Boson Protocol V2 contract suite
 *
 * Running with the appropriate npm script in package.json:
 * `npm run deploy-suite:local`
 *
 * Running with hardhat
 * `npx hardhat run --network hardhat scripts/deploy-suite.js`
 */

/**
 * Get the configuration data to be passed to the ConfigHandlerFacet initializer
 * @returns {{tokenAddress: string, treasuryAddress: string, voucherAddress: string, feePercentage: string, maxOffersPerGroup: string, maxTwinsPerBundle: string, maxOffersPerBundle: string}}
 */
function getConfig() {
  return [
    {
      token: protocolConfig.TOKEN[network],
      treasury: protocolConfig.TREASURY[network],
      voucherBeacon: protocolConfig.BEACON[network],
      beaconProxy: protocolConfig.BEACON_PROXY[network],
    },
    protocolConfig.limits,
    protocolConfig.fees,
  ];
}

/**
 * Get the contract addresses for supported NFT Auth token contracts
 * @returns {lensAddress: string, ensAddress: string}
 */
function getAuthTokenContracts() {
  return { lensAddress: authTokenAddresses.LENS[network], ensAddress: authTokenAddresses.ENS[network] };
}

/**
 * Get a list of no-arg initializer facet names to be cut into the Diamond
 */
function getNoArgFacetNames() {
  return [
    "AccountHandlerFacet",
    "SellerHandlerFacet",
    "BuyerHandlerFacet",
    "DisputeResolverHandlerFacet",
    "AgentHandlerFacet",
    "BundleHandlerFacet",
    "DisputeHandlerFacet",
    "ExchangeHandlerFacet",
    "FundsHandlerFacet",
    "GroupHandlerFacet",
    "MetaTransactionsHandlerFacet",
    "OfferHandlerFacet",
    "OrchestrationHandlerFacet",
    "TwinHandlerFacet",
    "PauseHandlerFacet",
  ];
}

async function main() {
  // Compile everything (in case run by node)
  await hre.run("compile");

  // Deployed contracts
  let contracts = [];
  const interfaceIds = await getInterfaceIds();
  const interfaceIdFromFacetName = (facetName) => interfaceIds[interfaceImplementers[facetName]];

  let transactionResponse;

  // Output script header
  const divider = "-".repeat(80);
  console.log(`${divider}\nBoson Protocol V2 Contract Suite Deployer\n${divider}`);
  console.log(`⛓  Network: ${network}\n📅 ${new Date()}`);

  // Get the protocol config
  const config = getConfig();
  const authTokenContracts = getAuthTokenContracts();

  // Get the accounts
  const accounts = await ethers.getSigners();
  const deployer = accounts[0];

  // If hardhat, get an address generated by the mnemonic
  const adminAddress = network === "hardhat" ? accounts[1].address : environments[network].adminAddress;

  // If admin address is unspecified, exit the deployment process
  if (adminAddress == ethers.constants.AddressZero || !adminAddress) {
    console.log("Admin address must not be zero address");
    process.exit(1);
  }

  console.log("🔱 Deployer account: ", deployer ? deployer.address : "not found" && process.exit());
  console.log(divider);

  console.log(`💎 Deploying AccessController, ProtocolDiamond, and Diamond utility facets...`);

  // Deploy the Diamond
  const [protocolDiamond, dlf, dcf, erc165f, accessController, diamondArgs] = await deployProtocolDiamond(
    maxPriorityFeePerGas
  );
  deploymentComplete("AccessController", accessController.address, [], "", contracts);
  deploymentComplete("DiamondLoupeFacet", dlf.address, [], interfaceIdFromFacetName("DiamondLoupeFacet"), contracts);
  deploymentComplete("DiamondCutFacet", dcf.address, [], interfaceIdFromFacetName("DiamondCutFacet"), contracts);
  deploymentComplete("ERC165Facet", erc165f.address, [], interfaceIdFromFacetName("ERC165Facet"), contracts);
  deploymentComplete("ProtocolDiamond", protocolDiamond.address, diamondArgs, "", contracts);

  console.log(`\n💎 Granting UPGRADER role...`);

  // Temporarily grant UPGRADER role to deployer account
  transactionResponse = await accessController.grantRole(
    Role.UPGRADER,
    deployer.address,
    await getFees(maxPriorityFeePerGas)
  );
  await transactionResponse.wait(confirmations);

  console.log(`\n💎 Deploying and initializing config facet...`);

  // Cut the ConfigHandlerFacet facet into the Diamond
  const {
    facets: [configHandlerFacet],
  } = await deployProtocolConfigFacet(protocolDiamond, config, maxPriorityFeePerGas);
  deploymentComplete(
    "ConfigHandlerFacet",
    configHandlerFacet.address,
    [],
    interfaceIdFromFacetName("ConfigHandlerFacet"),
    contracts
  );

  console.log(`\n💎 Deploying and initializing protocol handler facets...`);

  // Deploy and cut facets
  const deployedFacets = await deployProtocolHandlerFacets(protocolDiamond, getNoArgFacetNames(), maxPriorityFeePerGas);
  for (let i = 0; i < deployedFacets.length; i++) {
    const deployedFacet = deployedFacets[i];
    deploymentComplete(
      deployedFacet.name,
      deployedFacet.contract.address,
      [],
      interfaceIdFromFacetName(deployedFacet.name),
      contracts
    );
  }

  console.log(`\n⧉ Deploying Protocol Client implementation/proxy pairs...`);

  // Deploy the Protocol Client implementation/proxy pairs
  const protocolClientArgs = [protocolDiamond.address];
  const [impls, beacons, proxies] = await deployProtocolClients(protocolClientArgs, maxPriorityFeePerGas);
  const [bosonVoucherImpl] = impls;
  const [bosonClientBeacon] = beacons;
  const [bosonVoucherProxy] = proxies;

  // Gather the complete args that were used to create the proxies
  const bosonVoucherProxyArgs = [...protocolClientArgs, bosonVoucherImpl.address];

  // Report and prepare for verification
  deploymentComplete("BosonVoucher Logic", bosonVoucherImpl.address, [], "", contracts);
  deploymentComplete("BosonVoucher Beacon", bosonClientBeacon.address, bosonVoucherProxyArgs, "", contracts);
  deploymentComplete("BosonVoucher Proxy", bosonVoucherProxy.address, [], "", contracts);

  console.log(`\n🌐️Configuring and granting roles...`);

  // Cast Diamond to the IBosonConfigHandler interface for further interaction with it
  const bosonConfigHandler = await ethers.getContractAt("IBosonConfigHandler", protocolDiamond.address);

  // Add Voucher NFT addresses to protocol config
  transactionResponse = await bosonConfigHandler.setVoucherBeaconAddress(
    bosonClientBeacon.address,
    await getFees(maxPriorityFeePerGas)
  );
  await transactionResponse.wait(confirmations);

  transactionResponse = await bosonConfigHandler.setBeaconProxyAddress(
    bosonVoucherProxy.address,
    await getFees(maxPriorityFeePerGas)
  );
  await transactionResponse.wait(confirmations);

  // Add NFT auth token addresses to protocol config
  // LENS
  transactionResponse = await bosonConfigHandler.setAuthTokenContract(
    AuthTokenType.Lens,
    authTokenContracts.lensAddress,
    await getFees(maxPriorityFeePerGas)
  );
  await transactionResponse.wait(confirmations);

  // ENS
  // Skip the step for polygon networks, since ENS is not present there
  if (!(network === "polygon" || network === "mumbai")) {
    transactionResponse = await bosonConfigHandler.setAuthTokenContract(
      AuthTokenType.ENS,
      authTokenContracts.ensAddress,
      await getFees(maxPriorityFeePerGas)
    );
    await transactionResponse.wait(confirmations);
  }

  console.log(`✅ ConfigHandlerFacet updated with remaining post-initialization config.`);

  // Renounce temporarily granted UPGRADER role for deployer account
  transactionResponse = await accessController.renounceRole(
    Role.UPGRADER,
    deployer.address,
    await getFees(maxPriorityFeePerGas)
  );
  await transactionResponse.wait(confirmations);

  // Grant PROTOCOL role to the ProtocolDiamond contract
  transactionResponse = await accessController.grantRole(
    Role.PROTOCOL,
    protocolDiamond.address,
    await getFees(maxPriorityFeePerGas)
  );
  await transactionResponse.wait(confirmations);

  if (adminAddress.toLowerCase() != deployer.address.toLowerCase()) {
    // Grant ADMIN role to the specified admin address
    // Skip this step if adminAddress is the deployer
    transactionResponse = await accessController.grantRole(
      Role.ADMIN,
      adminAddress,
      await getFees(maxPriorityFeePerGas)
    );
    await transactionResponse.wait(confirmations);
  }

  console.log(`✅ Granted roles to appropriate contract and addresses.`);

  const contractsPath = await writeContracts(contracts);
  console.log(`✅ Contracts written to ${contractsPath}`);

  // Verify on test node if test env
  // Just checks that there is contract code at the expected addresses
  if (network === "test" || network === "localhost") {
    await verifyOnTestEnv(contracts);
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
