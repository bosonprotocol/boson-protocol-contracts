const fs = require("fs");
const hre = require("hardhat");
const { ZeroAddress, getContractAt, provider, getSigners, getContractFactory } = hre.ethers;
const network = hre.network.name;
const { getFacets } = require("./config/upgrade/facet-upgrade");
const environments = require("../environments");
const tipMultiplier = BigInt(environments.tipMultiplier);
const tipSuggestion = 1500000000n; // js always returns this constant, it does not vary per block
const maxPriorityFeePerGas = tipSuggestion + tipMultiplier;
const {
  deploymentComplete,
  readContracts,
  writeContracts,
  checkRole,
  addressNotFound,
  listAccounts,
} = require("./util/utils.js");
const { deployProtocolFacets } = requireUncached("./util/deploy-protocol-handler-facets.js");
const {
  FacetCutAction,
  getSelectors,
  removeSelectors,
  cutDiamond,
  getInitializeCalldata,
} = require("./util/diamond-utils.js");
const { getInterfaceIds, interfaceImplementers } = require("./config/supported-interfaces.js");
const packageFile = require("../package.json");
const readline = require("readline");
const FacetCut = require("./domain/FacetCut");
const path = require("path");
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
const { ACCOUNTS } = require("../test/upgrade/utils/accounts.js");
const { Wallet } = require("ethers");

/**
 * Upgrades or removes existing facets, or adds new facets.
 *
 * Prerequisite:
 * - Admin must have UPGRADER role. Use `manage-roles.js` to grant it.
 *
 * Process:
 *  1.  Edit scripts/config/facet-upgrade.js.
 *  1a. Provide a list of facets that needs to be upgraded (field "addOrUpgrade") or removed completely (field "remove")
 *  1b. Optionally you can specify which selectors should be ignored (field "skip"). You don't have to specify "initialize()" since it's ignored by default
 *  2. Update protocol version in package.json. If not, script will prompt you to confirm that version remains unchanged.
 *  2. Run the appropriate npm script in package.json to upgrade facets for a given network
 *  3. Save changes to the repo as a record of what was upgraded
 */
async function main(env, facetConfig, version, functionNamesToSelector) {
  // Bail now if hardhat network, unless the upgrade is tested
  if (network === "hardhat" && env !== "upgrade-test" && !env.includes("dry-run")) process.exit();

  const { chainId } = await provider.getNetwork();
  const contractsFile = readContracts(chainId, network, env);
  let contracts = contractsFile.contracts;
  const interfaceIds = await getInterfaceIds(false);
  const interfaceIdFromFacetName = (facetName) => interfaceIds[interfaceImplementers[facetName]];

  const divider = "-".repeat(80);
  console.log(`${divider}\nBoson Protocol Contract Suite Upgrader\n${divider}`);
  console.log(`â›“  Network: ${network}\nðŸ“… ${new Date()}`);

  // Check that version and
  if (version == contractsFile.protocolVersion && env !== "upgrade-test") {
    const answer = await getUserResponse("Protocol version has already been deployed. Proceed anyway? (y/n) ", [
      "y",
      "yes",
      "n",
      "no",
    ]);
    switch (answer.toLowerCase()) {
      case "y":
      case "yes":
        break;
      case "n":
      case "no":
      default:
        process.exit(1);
    }
  }

  // Load pre and post upgrade scripts (if they exist)
  let preUpgrade, postUpgrade;
  const hookPath = __dirname + `/upgrade-hooks/${version}.js`;
  if (fs.existsSync(hookPath)) {
    ({ preUpgrade, postUpgrade } = require(hookPath));
  }

  // If hardhat, get an address generated by the mnemonic
  let adminAddress = network === "hardhat" ? (await getSigners())[0].address : environments[network].adminAddress;

  // Special case for localhost Docker environment
  if (network === "localhost" && env === "localhost") {
    adminAddress = ACCOUNTS[0].address;
    // Override getSigners to return Docker accounts for all ethers operations
    hre.ethers.getSigners = async () => {
      return [new Wallet(ACCOUNTS[0].privateKey, provider)];
    };
  }

  // If admin address is unspecified, exit the process
  if (adminAddress == ZeroAddress || !adminAddress) {
    console.log("Admin address must not be zero address");
    process.exit(1);
  }

  // Get list of accounts managed by node
  const nodeAccountList = (await listAccounts()).map((address) => address.toLowerCase());

  // For localhost Docker environment, skip account check and use signer directly
  if (network === "localhost" && env === "localhost") {
    console.log("ðŸ”± Admin account: ", adminAddress, "(Docker localhost)");
  } else if (nodeAccountList.includes(adminAddress.toLowerCase())) {
    console.log("ðŸ”± Admin account: ", adminAddress);
  } else {
    console.log("ðŸ”± Admin account not found");
    process.exit(1);
  }
  console.log(divider);

  // Get addresses of currently deployed contracts
  const protocolAddress = contracts.find((c) => c.name === "ProtocolDiamond")?.address;

  // Check if admin has UPGRADER role
  checkRole(contracts, "UPGRADER", adminAddress);

  if (!protocolAddress) {
    return addressNotFound("ProtocolDiamond");
  }

  let facets;
  if (facetConfig) {
    facets = JSON.parse(facetConfig);
  } else {
    // Try to load from upgrade directory
    const upgradeConfigPath = path.join(__dirname, "config", "upgrade", `${version}.js`);
    if (fs.existsSync(upgradeConfigPath)) {
      const { getFacets: getVersionFacets } = require(upgradeConfigPath);
      facets = await getVersionFacets();
    } else {
      // Get values from default config file
      facets = await getFacets();
    }
  }

  let deployedFacets = [];
  if (preUpgrade) {
    console.log("\nðŸ“‹Running pre-upgrade script...");
    const { facets: preUpgradeModifiedFacets, deployedFacets: preUpgradeDeployedFacets } = await preUpgrade(
      protocolAddress,
      facets,
      env
    );
    facets = preUpgradeModifiedFacets;
    deployedFacets = preUpgradeDeployedFacets;
  }

  // Deploy new facets
  deployedFacets = [
    ...deployedFacets,
    ...(await deployProtocolFacets(facets.addOrUpgrade, facets.facetsToInit, maxPriorityFeePerGas)),
  ];

  // Cast Diamond to DiamondCutFacet, DiamondLoupeFacet and IERC165Extended
  const diamondCutFacet = await getContractAt("DiamondCutFacet", protocolAddress);
  const diamondLoupe = await getContractAt("DiamondLoupeFacet", protocolAddress);

  const facetCutRemove = [];
  const interfacesToRemove = {},
    interfacesToAdd = {};
  const removedSelectors = []; // global list of selectors to be removed

  functionNamesToSelector = JSON.parse(functionNamesToSelector);

  // Remove facets
  for (const facetToRemove of facets.remove) {
    // Get currently registered selectors
    const oldFacet = contracts.find((i) => i.name === facetToRemove);

    let registeredSelectors;
    if (oldFacet) {
      // Facet exists, so all selectors should be removed
      registeredSelectors = await diamondLoupe.facetFunctionSelectors(oldFacet.address);
    } else {
      // Facet does not exist, skip next steps
      continue;
    }

    // Remove old entry from contracts
    contracts = contracts.filter((i) => i.name !== facetToRemove);

    // All selectors must be removed
    let selectorsToRemove = registeredSelectors; // all selectors must be removed
    removedSelectors.push(selectorsToRemove); // add to global list

    // Removing the selectors
    facetCutRemove.push([ZeroAddress, FacetCutAction.Remove, selectorsToRemove]);

    if (oldFacet) {
      // Remove support for old interface
      if (!oldFacet.interfaceId) {
        console.log(
          `Could not find interface id for old facet ${oldFacet.name}.\nYou might need to remove its interfaceId from "supportsInterface" manually.`
        );
      } else {
        // Remove from smart contract
        interfacesToRemove[facetToRemove] = oldFacet.interfaceId;

        // Check if interface was shared across other facets and update contracts info
        contracts = contracts.map((entry) => {
          if (entry.interfaceId == oldFacet.interfaceId) {
            entry.interfaceId = "";
          }
          return entry;
        });
      }
    }
  }

  // Manage new or upgraded facets
  for (const [index, newFacet] of deployedFacets.entries()) {
    // Get currently registered selectors
    const oldFacet = contracts.find((i) => i.name === newFacet.name);
    let registeredSelectors;

    if (oldFacet) {
      // Facet already exists and is only upgraded
      registeredSelectors = await diamondLoupe.facetFunctionSelectors(oldFacet.address);
    } else {
      // Facet is new
      registeredSelectors = [];
    }

    // Remove old entry from contracts
    contracts = contracts.filter((i) => i.name !== newFacet.name);

    const newFacetInterfaceId = interfaceIdFromFacetName(newFacet.name);
    deploymentComplete(
      newFacet.name,
      await newFacet.contract.getAddress(),
      newFacet.constructorArgs,
      newFacetInterfaceId,
      contracts
    );

    // Get new selectors from compiled contract
    let { selectors: newSelectors, signatureToNameMapping } = getSelectors(newFacet.contract, true);
    functionNamesToSelector = { ...functionNamesToSelector, ...signatureToNameMapping };

    // Initialize selectors should not be added
    const facetFactory = await getContractFactory(newFacet.name);
    const { selector } = facetFactory.interface.getFunction("initialize");
    newSelectors = newSelectors.remove([selector]);

    // Determine actions to be made
    let selectorsToReplace = [...registeredSelectors.filter((value) => newSelectors.includes(value))];
    let selectorsToRemove = [...registeredSelectors.filter((value) => !selectorsToReplace.includes(value))];
    let selectorsToAdd = [...newSelectors.filter((value) => !selectorsToReplace.includes(value))];

    // Skip selectors if set in config
    let selectorsToSkip = facets.skipSelectors[newFacet.name] ? facets.skipSelectors[newFacet.name] : [];
    selectorsToReplace = removeSelectors(selectorsToReplace, selectorsToSkip);
    selectorsToRemove = removeSelectors(selectorsToRemove, selectorsToSkip);
    selectorsToAdd = removeSelectors(selectorsToAdd, selectorsToSkip);

    // Check if selectors that are being added are not registered yet on some other facet
    // If collision is found, user must choose to either (s)kip it or (r)eplace it.
    let skipAll, replaceAll;

    for (const selectorToAdd of selectorsToAdd) {
      if (removedSelectors.flat().includes(selectorToAdd)) {
        continue;
      }

      const existingFacetAddress = await diamondLoupe.facetAddress(selectorToAdd);
      if (existingFacetAddress != ZeroAddress) {
        // Selector exist on some other facet
        const selectorName = signatureToNameMapping[selectorToAdd];

        let answer;
        if (!(skipAll || replaceAll)) {
          const prompt = `Selector ${selectorName} is already registered on facet ${existingFacetAddress}. Do you want to (r)eplace or (s)kip it?\nUse "R" os "S" to apply the same choice to all remaining selectors in this facet. `;
          answer = await getUserResponse(prompt, ["r", "s", "R", "S"]);
          if (answer == "R") {
            replaceAll = true;
          } else if (answer == "S") {
            skipAll = true;
          }
        }
        if (replaceAll || answer == "r") {
          // User chose to replace
          selectorsToReplace.push(selectorToAdd);
          selectorsToAdd = selectorsToAdd.filter((s) => s !== selectorToAdd);
        } else {
          // User chose to skip
          selectorsToAdd = selectorsToAdd.filter((s) => s !== selectorToAdd);
        }
      }
    }

    const newFacetAddress = await newFacet.contract.getAddress();

    if (selectorsToAdd.length > 0) {
      deployedFacets[index].cut.push([newFacetAddress, FacetCutAction.Add, [...selectorsToAdd]]);
    }
    if (selectorsToReplace.length > 0) {
      deployedFacets[index].cut.push([newFacetAddress, FacetCutAction.Replace, [...selectorsToReplace]]);
    }
    if (selectorsToRemove.length > 0) {
      deployedFacets[index].cut.push([ZeroAddress, FacetCutAction.Remove, [...selectorsToRemove]]);
      removedSelectors.push(selectorsToRemove); // add to global list
    }

    if (oldFacet && (selectorsToAdd.length > 0 || selectorsToRemove.length > 0)) {
      if (!oldFacet.interfaceId) {
        console.log(
          `Could not find interface id for old facet ${oldFacet.name}.\nYou might need to remove its interfaceId from "supportsInterface" manually.`
        );
      } else {
        if (oldFacet.interfaceId == newFacetInterfaceId) {
          // This can happen if interface is shared across facets and interface was updated already
          continue;
        }

        interfacesToRemove[oldFacet.name] = oldFacet.interfaceId;

        // Check if interface was shared across other facets and update contracts info
        contracts = contracts.map((entry) => {
          if (entry.interfaceId == oldFacet.interfaceId) {
            entry.interfaceId = newFacetInterfaceId;
          }
          return entry;
        });
      }

      const erc165 = await getContractAt("contracts/interfaces/IERC165.sol:IERC165", protocolAddress);
      const support = await erc165.supportsInterface(newFacetInterfaceId);
      if (!support) {
        interfacesToAdd[oldFacet.name] = newFacetInterfaceId;
      }
    }
  }

  // Get ProtocolInitializationHandlerFacet from deployedFacets when added/replaced in this upgrade or get it from contracts if already deployed
  let protocolInitializationFacet = await getInitializationFacet(deployedFacets, contracts);
  const facetsToInit = deployedFacets.filter((facet) => facet.initialize) ?? [];
  const initializeCalldata = await getInitializeCalldata(
    facetsToInit,
    version,
    true,
    facets.initializationData ?? "0x",
    protocolInitializationFacet,
    Object.values(interfacesToRemove),
    Object.values(interfacesToAdd)
  );

  await cutDiamond(
    await diamondCutFacet.getAddress(),
    maxPriorityFeePerGas,
    deployedFacets,
    await protocolInitializationFacet.getAddress(),
    initializeCalldata,
    facetCutRemove
  );

  // Logs
  for (const facet of deployedFacets) {
    console.log(`\nðŸ“‹ Facet: ${facet.name}`);

    let { cut } = facet;
    cut = cut.map((c) => {
      const facetCut = FacetCut.fromStruct(c);
      return facetCut.toObject();
    });

    logFacetCut(cut, functionNamesToSelector);
  }

  console.log(`\nðŸ’€ Removed facets:\n\t${facets.remove.join("\n\t")}`);

  Object.keys(interfacesToAdd).length &&
    console.log(
      `ðŸ“‹ Added interfaces:\n\t${Object.entries(interfacesToAdd)
        .map((v) => `${v[1]} (${v[0]})`)
        .join("\n\t")}`
    );
  Object.keys(interfacesToRemove).length &&
    console.log(
      `ðŸ’€ Removed interfaces:\n\t${Object.entries(interfacesToRemove)
        .map((v) => `${v[1]} (${v[0]})`)
        .join("\n\t")}`
    );

  console.log(divider);

  if (postUpgrade) {
    console.log(`\nðŸ“‹ Running post-upgrade script...`);
    await postUpgrade(protocolAddress);
  }

  // Cast diamond to ProtocolInitializationHandlerFacet
  protocolInitializationFacet = await getContractAt("ProtocolInitializationHandlerFacet", protocolAddress);
  const newVersion = (await protocolInitializationFacet.getVersion()).replace(/\0/g, "");

  console.log(`\nðŸ“‹ New version: ${newVersion}`);

  const contractsPath = await writeContracts(contracts, env, newVersion);
  console.log(divider);
  console.log(`âœ… Contracts written to ${contractsPath}`);
  console.log(divider);

  console.log(`\nðŸ“‹ Diamond upgraded.`);
  console.log("\n");

  if (env == "prod") {
    packageFile.version = newVersion;

    fs.writeFileSync("../package.json", JSON.stringify(packageFile, null, 2));
  }
}

async function getUserResponse(question, validResponses) {
  console.error(question);
  const answer = await new Promise((resolve) => {
    rl.question("", resolve);
  });
  if (validResponses.includes(answer)) {
    return answer;
  } else {
    console.error("Invalid response!");
    return await getUserResponse(question, validResponses);
  }
}

const getInitializationFacet = async (deployedFacets, contracts) => {
  let protocolInitializationFacet;

  const protocolInitializationName = "ProtocolInitializationHandlerFacet";
  const protocolInitializationDeployed = deployedFacets.find((f) => f.name == protocolInitializationName);

  if (protocolInitializationDeployed) {
    protocolInitializationFacet = protocolInitializationDeployed.contract;
  } else {
    protocolInitializationFacet = await getContractAt(
      protocolInitializationName,
      contracts.find((i) => i.name == protocolInitializationName).address
    );
  }

  if (!protocolInitializationFacet) {
    console.error("Could not find ProtocolInitializationHandlerFacet");
    process.exit(1);
  }

  return protocolInitializationFacet;
};

const logFacetCut = (cut, functionNamesToSelector) => {
  for (const action in FacetCutAction) {
    cut
      .filter((c) => c.action == FacetCutAction[action])
      .forEach((c) => {
        console.log(
          `ðŸ’Ž ${action} selectors:\n\t${c.functionSelectors
            .map((selector) => `${functionNamesToSelector[selector]}: ${selector}`)
            .join("\n\t")}`
        );
      });
  }
};

/**
 * Require uncached node module
 *
 * Normally, if the same module is required multiple times, the first time it is loaded and cached.
 * If the module is changed during the execution, the cache is not updated, so the old version is returned.
 * This function deletes the cache for the specified module and requires it again.
 *
 * Use case:
 * Upgrade test `test/upgrade/clients/BosonVoucher-2.1.0-2.2.0.js` deploys version 2.1.0 of the contract and then upgrades it to 2.2.0.
 * Since deployment script changed between versions, current deployment script cannot be used to deploy 2.1.0.
 * For first deployment, we checkout old deployment script, which uses `deployProtocolHandlerFacets` from `./util/deploy-protocol-handler-facets.js`.
 * To upgrade to 2.2.0, we switch back to current upgrade script, which uses `deployProtocolFacets` from `./util/deploy-protocol-handler-facets.js`.
 * If the cache is not cleared, requiring module `./util/deploy-protocol-handler-facets.js` returns the old version, where `deployProtocolFacets` does not
 * exist yet and the upgrade fails.
 * If the cache is cleared, the new version is required and the upgrade succeeds.
 *
 * @param {string} module - Module to require
 */
function requireUncached(module) {
  delete require.cache[require.resolve(module)];
  return require(module);
}

exports.upgradeFacets = main;
